fun coin_address<CoinType>(): address {
  let type_info = type_info::type_of<CoinType>();
  type_info::account_address(&type_info)
}

fun vesting::coin_address<#0>(): address 
     var $t0|$t0: type_info::TypeInfo
     var $t1: type_info::TypeInfo
     var $t2: &type_info::TypeInfo
     var $t3: address

  let type_info = type_info::type_of<CoinType>();
  0: $t1 := type_info::type_of<#0>()  // #0 范型函数调用
  1: $t0 := $t1

  type_info::account_address(&type_info)
  2: $t2 := borrow_local($t0) // 引用
  3: $t3 := type_info::account_address($t2)

  4: return $t3

============================================

public fun pow(base: u128, exp: u8): u128 {
    let result = 1u128;
    loop {
        if (exp & 1 == 1) { result = result * base; };
        exp = exp >> 1;
        base = base * base;
        if (exp == 0u8) { break };
    };
    result
}

public fun math::pow($t0|$t0: u128, $t1|$t1: u8): u128 {
     var $t2|$t2: u128
     var $t3: u128
     var $t4: u8
     var $t5: u8
     var $t6: u8
     var $t7: u8
     var $t8: bool
     var $t9: u128
     var $t10: u128
     var $t11: u128
     var $t12: u8
     var $t13: u8
     var $t14: u8
     var $t15: u128
     var $t16: u128
     var $t17: u128
     var $t18: u8
     var $t19: u8
     var $t20: bool
     var $t21: u128

let result = 1u128;
  0: $t3 := 1
  1: $t2 := $t3
  2: goto 3 // goto line 3

if (exp & 1 == 1)
  3: label L6 // L6 基本块入口
  4: $t4 := copy($t1)
  5: $t5 := 1
  6: $t6 := &($t4, $t5)
  7: $t7 := 1
  8: $t8 := ==($t6, $t7)
  9: if ($t8) goto 10 else goto 18 // if 分支

 10: label L1
 11: goto 12

result = result * base; 
 12: label L2
 13: $t9 := move($t2)
 14: $t10 := copy($t0)
 15: $t11 := *($t9, $t10) // 算数运算
 16: $t2 := $t11
 17: goto 18
 
 exp = exp >> 1;
 18: label L0 // label 表示一个基本快的入口处
 19: $t12 := move($t1)
 20: $t13 := 1
 21: $t14 := >>($t12, $t13) // 移位运算
 22: $t1 := $t14

base = base * base;
 23: $t15 := copy($t0)
 24: $t16 := move($t0)
 25: $t17 := *($t15, $t16)
 26: $t0 := $t17

if (exp == 0u8) { break };
 27: $t18 := copy($t1)
 28: $t19 := 0
 29: $t20 := ==($t18, $t19)
 30: if ($t20) goto 31 else goto 33

break
 31: label L4
 32: goto 35

loop
 33: label L3
 34: goto 3

return result
 35: label L5
 36: $t21 := move($t2)
 37: return $t21

============================================

fun overflowing_add(a: u64, b: u64): (u64, bool) {
    let a128 = (a as u128);
    let b128 = (b as u128);
    let r = a128 + b128;
    if (r > U64_MAX) {
        let overflow = r - U64_MAX - 1;
        ((overflow as u64), true)
    } else {
        (((a128 + b128) as u64), false)
    }
}

fun u256::overflowing_add($t0|$t0: u64, $t1|$t1: u64): (u64, bool) {
     var $t2|$t2: u64 // 所有变量和中间变量的类型
     var $t3|$t3: bool
     var $t4|$t4: u128
     var $t5|$t5: u128
     var $t6|$t6: u128
     var $t7: u64
     var $t8: u128
     var $t9: u64
     var $t10: u128
     var $t11: u128
     var $t12: u128
     var $t13: u128
     var $t14: u128
     var $t15: u128
     var $t16: bool
     var $t17: u128
     var $t18: u128
     var $t19: u128
     var $t20: u128
     var $t21: u128
     var $t22: u64
     var $t23: bool
     var $t24: u128
     var $t25: u128
     var $t26: u128
     var $t27: u64
     var $t28: bool
     var $t29: u64
     var $t30: bool

let a128 = (a as u128);
  0: $t7 := move($t0)
  1: $t8 := (u128)($t7) // 类型转换
  2: $t4 := $t8

let b128 = (b as u128);
  3: $t9 := move($t1)
  4: $t10 := (u128)($t9) // 类型转换
  5: $t5 := $t10

let r = a128 + b128;
  6: $t11 := copy($t4)
  7: $t12 := copy($t5)
  8: $t13 := +($t11, $t12) // 加法运算
  9: $t6 := $t13

if (r > U64_MAX)
 10: $t14 := copy($t6)
 11: $t15 := 18446744073709551615 // LdConst
 12: $t16 := >($t14, $t15)
 13: if ($t16) goto 14 else goto 25

let overflow = r - U64_MAX - 1;
 14: label L1
 15: $t17 := move($t6)
 16: $t18 := 18446744073709551615
 17: $t19 := -($t17, $t18)
 18: $t20 := 1
 19: $t21 := -($t19, $t20)

return ((overflow as u64), true)
 20: $t22 := (u64)($t21)
 21: $t23 := true
 22: $t3 := $t23 // 缺少 phi 函数，存在重复赋值
 23: $t2 := $t22
 24: goto 34

(((a128 + b128) as u64), false)
 25: label L0
 26: $t24 := move($t4)
 27: $t25 := move($t5)
 28: $t26 := +($t24, $t25)
 29: $t27 := (u64)($t26) // 类型转换
 30: $t28 := false
 31: $t3 := $t28 // 重复赋值，非 ssa 
 32: $t2 := $t27
 33: goto 34

return
 34: label L2
 35: $t29 := move($t2)
 36: $t30 := move($t3)
 37: return ($t29, $t30) // return 多返回值
}

vector::append(&mut ret, bcs::to_bytes(&get(a, 0)));
  0: $t10 := vector::empty<u8>() // 空 vector
  1: $t9 := $t10
  2: $t11 := borrow_local($t9) // 引用
  3: $t2 := $t11
  4: $t12 := copy($t0)
  5: $t13 := 0
  6: $t14 := u256::get($t12, $t13)
  7: $t1 := $t14
  8: $t15 := move($t2)
  9: $t16 := borrow_local($t1)
 10: $t17 := bcs::to_bytes<u64>($t16)
 11: vector::append<u8>($t15, $t17)
 12: $t18 := borrow_local($t9)